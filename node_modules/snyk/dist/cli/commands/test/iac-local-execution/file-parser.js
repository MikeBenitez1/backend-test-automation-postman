"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFiles = void 0;
const kubernetes_parser_1 = require("./parsers/kubernetes-parser");
const terraform_file_parser_1 = require("./parsers/terraform-file-parser");
const terraform_plan_parser_1 = require("./parsers/terraform-plan-parser");
const path = require("path");
async function parseFiles(filesData) {
    const parsedFiles = [];
    const failedFiles = [];
    for (const fileData of filesData) {
        try {
            parsedFiles.push(...tryParseIacFile(fileData));
        }
        catch (err) {
            if (filesData.length === 1)
                throw err;
            failedFiles.push(generateFailedParsedFile(fileData, err));
        }
    }
    return {
        parsedFiles,
        failedFiles,
    };
}
exports.parseFiles = parseFiles;
function generateFailedParsedFile({ fileType, filePath, fileContent }, err) {
    return {
        err,
        failureReason: err.message,
        fileType,
        filePath,
        fileContent,
        engineType: null,
        jsonContent: null,
    };
}
const TF_PLAN_NAME = 'tf-plan.json';
function tryParseIacFile(fileData) {
    switch (fileData.fileType) {
        case 'yaml':
        case 'yml':
        case 'json':
            // TODO: this is a temporary approach for the internal release only
            if (path.basename(fileData.filePath) === TF_PLAN_NAME) {
                return terraform_plan_parser_1.tryParsingTerraformPlan(fileData);
            }
            return kubernetes_parser_1.tryParsingKubernetesFile(fileData);
        case 'tf':
            return terraform_file_parser_1.tryParsingTerraformFile(fileData);
        default:
            throw new Error('Invalid IaC file');
    }
}
//# sourceMappingURL=file-parser.js.map