"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearPolicyEngineCache = exports.scanFiles = void 0;
const types_1 = require("./types");
const opa_wasm_1 = require("@open-policy-agent/opa-wasm");
const fs = require("fs");
const local_cache_1 = require("./local-cache");
async function scanFiles(parsedFiles) {
    // TODO: gracefully handle failed scans
    const scanResults = [];
    for (const parsedFile of parsedFiles) {
        const policyEngine = await getPolicyEngine(parsedFile.engineType);
        const result = policyEngine.scanFile(parsedFile);
        scanResults.push(result);
    }
    return scanResults;
}
exports.scanFiles = scanFiles;
async function getPolicyEngine(engineType) {
    if (policyEngineCache[engineType]) {
        return policyEngineCache[engineType];
    }
    const policyEngine = await buildPolicyEngine(engineType);
    policyEngineCache[engineType] = policyEngine;
    return policyEngineCache[engineType];
}
// used in tests only
function clearPolicyEngineCache() {
    policyEngineCache = {
        [types_1.EngineType.Kubernetes]: null,
        [types_1.EngineType.Terraform]: null,
    };
}
exports.clearPolicyEngineCache = clearPolicyEngineCache;
let policyEngineCache = {
    [types_1.EngineType.Kubernetes]: null,
    [types_1.EngineType.Terraform]: null,
};
async function buildPolicyEngine(engineType) {
    const [policyEngineCoreDataPath, policyEngineMetaDataPath,] = local_cache_1.getLocalCachePath(engineType);
    try {
        const wasmFile = fs.readFileSync(policyEngineCoreDataPath);
        const policyMetaData = fs.readFileSync(policyEngineMetaDataPath);
        const policyMetadataAsJson = JSON.parse(policyMetaData.toString());
        const opaWasmInstance = await opa_wasm_1.loadPolicy(Buffer.from(wasmFile));
        opaWasmInstance.setData(policyMetadataAsJson);
        return new PolicyEngine(opaWasmInstance);
    }
    catch (err) {
        throw new Error(`Failed to build policy engine from path: ${local_cache_1.LOCAL_POLICY_ENGINE_DIR}: \n err: ${err.message}`);
    }
}
class PolicyEngine {
    constructor(opaWasmInstance) {
        this.opaWasmInstance = opaWasmInstance;
        this.opaWasmInstance = opaWasmInstance;
    }
    evaluate(data) {
        return this.opaWasmInstance.evaluate(data)[0].result;
    }
    scanFile(iacFile) {
        try {
            const violatedPolicies = this.evaluate(iacFile.jsonContent);
            return Object.assign(Object.assign({}, iacFile), { violatedPolicies });
        }
        catch (err) {
            // TODO: to distinguish between different failure reasons
            throw new Error(`Failed to run policy engine: ${err}`);
        }
    }
}
//# sourceMappingURL=file-scanner.js.map