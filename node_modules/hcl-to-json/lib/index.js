// Generated by CoffeeScript 1.12.7
var TOKENS, debug, get, hcltojson, set, tokenize, utils;

debug = (require('debug'))('hcltojson:main');

get = require('lodash.get');

set = require('lodash.set');

TOKENS = require('./tokens');

tokenize = require('./tokenize');

utils = require('./utils');

module.exports = hcltojson = function(hclInput) {
  var assignment, cur, hereDocAhead, hereDocCopy, hereDocPart, hereDocToken, i, inBlock, inList, input, itemInList, json, len, list, part, path, ref, ref1, stack;
  debug('input', hclInput);
  if (!(hclInput != null ? typeof hclInput.trim === "function" ? hclInput.trim() : void 0 : void 0)) {
    return {};
  }
  input = "" + hclInput;
  input = tokenize(input);
  json = {};
  stack = [];
  inBlock = 0;
  inList = 0;
  itemInList = 0;
  assignment = false;
  hereDocAhead = false;
  hereDocPart = '';
  hereDocCopy = "" + hclInput;
  hereDocToken = null;
  ref = input.split(TOKENS.SPACE);
  for (i = 0, len = ref.length; i < len; i++) {
    part = ref[i];
    if (!part) {
      continue;
    }
    if (part === TOKENS.COMMA) {
      continue;
    }
    debug('json', JSON.stringify(json, " ", 2));
    path = stack.join('.');
    debug('path', path);
    if (!assignment) {
      part = part.replace(/\"/g, '');
    }
    if (hereDocAhead) {
      hereDocToken = part;
      hereDocAhead = false;
      ref1 = utils.getHereDoc(hereDocCopy, hereDocToken), hereDocPart = ref1[0], hereDocCopy = ref1[1];
      debug('heredoc', part, hereDocPart);
      continue;
    }
    if (hereDocToken) {
      if (part === hereDocToken) {
        part = hereDocPart;
        hereDocToken = null;
        hereDocPart = '';
        assignment = true;
      } else {
        continue;
      }
    }
    if (assignment) {
      debug('assignment', part);
      switch (part) {
        case TOKENS.LBRACKET:
          set(json, path, []);
          inList++;
          break;
        case TOKENS.LBRACE:
          inBlock++;
          break;
        case TOKENS.RBRACE:
          inBlock--;
          if (inBlock <= 0) {
            stack = [];
          }
          break;
        case TOKENS.HEREDOC:
          hereDocAhead = true;
          break;
        default:
          part = utils.doConversions(part);
          set(json, path, part);
          stack.pop();
          if (inBlock <= 0) {
            stack = [];
          }
      }
      assignment = false;
      continue;
    }
    switch (part) {
      case TOKENS.LBRACE:
        inBlock++;
        if (inList > 0) {
          if (Array.isArray(cur = get(json, path))) {
            cur.push({});
            set(json, path, cur);
            stack.push("" + (cur.length - 1));
          }
        }
        break;
      case TOKENS.RBRACE:
        stack.pop();
        inBlock--;
        if (itemInList > 0) {
          stack.pop();
          itemInList--;
        }
        if (inBlock <= 0) {
          stack = [];
        }
        break;
      case TOKENS.RBRACKET:
        stack.pop();
        inList--;
        break;
      case TOKENS.ASSIGN:
        assignment = true;
        break;
      default:
        if (inList > 0) {
          if (Array.isArray(list = get(json, path))) {
            list.push(part.replace(/,$/, ''));
            set(json, path, list);
          } else if (inBlock) {
            stack.push(part);
          }
        } else {
          if (stack.length > 2 && part === stack[stack.length - 1]) {
            stack.pop();
          }
          stack.push(part);
          path = stack.join('.');
          debug('path end', path);
          if (stack.length > 2 && (cur = get(json, path))) {
            itemInList++;
            if (Array.isArray(cur)) {
              cur.push({});
              set(json, path, cur);
              stack.push("" + (cur.length - 1));
            } else {
              cur = [cur, {}];
              set(json, path, cur);
              stack.push("" + itemInList);
            }
          } else {
            if (get(json, path)) {
              continue;
            }
            set(json, path, {});
          }
        }
    }
  }
  return json;
};
